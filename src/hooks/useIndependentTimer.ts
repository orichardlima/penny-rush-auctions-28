import { useState, useEffect, useCallback, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';

interface UseBackendTimerProps {
  auctionId: string;
}

export const useBackendTimer = ({ auctionId }: UseBackendTimerProps) => {
  const [localTimeLeft, setLocalTimeLeft] = useState<number>(0);
  const [lastBidCount, setLastBidCount] = useState<number>(0);
  const [isVerifying, setIsVerifying] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const [auctionStatus, setAuctionStatus] = useState<string>('active');
  const [lastBidAt, setLastBidAt] = useState<string | null>(null);
  
  // Estados para dados do leil√£o sincronizados com o timer
  const [auctionData, setAuctionData] = useState({
    currentPrice: 0,
    totalBids: 0,
    recentBidders: [] as string[],
    winnerName: null as string | null
  });
  
  const localTimerRef = useRef<NodeJS.Timeout>();
  const bidCheckIntervalRef = useRef<NodeJS.Timeout>();
  const lastVerifyingStart = useRef<number>();
  
  // Usar refs para evitar recria√ß√µes desnecess√°rias do checkForNewBids
  const lastBidCountRef = useRef(lastBidCount);
  const lastBidAtRef = useRef(lastBidAt);
  const auctionStatusRef = useRef(auctionStatus);
  const isVerifyingRef = useRef(isVerifying);
  const localTimeLeftRef = useRef(localTimeLeft);
  
  // Atualizar refs quando valores mudarem
  useEffect(() => {
    lastBidCountRef.current = lastBidCount;
  }, [lastBidCount]);
  
  useEffect(() => {
    lastBidAtRef.current = lastBidAt;
  }, [lastBidAt]);
  
  useEffect(() => {
    auctionStatusRef.current = auctionStatus;
  }, [auctionStatus]);
  
  useEffect(() => {
    isVerifyingRef.current = isVerifying;
  }, [isVerifying]);
  
  useEffect(() => {
    localTimeLeftRef.current = localTimeLeft;
  }, [localTimeLeft]);

  // Limpar timers
  const clearTimers = useCallback(() => {
    if (localTimerRef.current) {
      clearInterval(localTimerRef.current);
      localTimerRef.current = undefined;
    }
    if (bidCheckIntervalRef.current) {
      clearInterval(bidCheckIntervalRef.current);
      bidCheckIntervalRef.current = undefined;
    }
  }, []);

  // Iniciar timer local aut√¥nomo que decrementa a cada 1 segundo
  const startLocalTimer = useCallback((initialTime: number) => {
    console.log(`üöÄ [${auctionId}] Iniciando timer aut√¥nomo: ${initialTime}s`);
    
    if (localTimerRef.current) {
      clearInterval(localTimerRef.current);
    }

    setLocalTimeLeft(initialTime);
    setIsVerifying(false);

    localTimerRef.current = setInterval(() => {
      setLocalTimeLeft(prev => {
        const newTime = Math.max(0, prev - 1);
        console.log(`‚è∞ [${auctionId}] Timer: ${prev}s ‚Üí ${newTime}s`);
        
        if (newTime === 0) {
          console.log(`üîö [${auctionId}] Timer chegou a 0 - Verificando lances v√°lidos`);
          setIsVerifying(true);
          lastVerifyingStart.current = Date.now();
        }
        
        return newTime;
      });
    }, 1000);
  }, [auctionId]);

  // Buscar dados completos do leil√£o
  const fetchCompleteAuctionData = useCallback(async () => {
    try {
      const { data, error } = await supabase
        .from('auctions')
        .select('last_bid_at, total_bids, status, time_left, current_price, winner_name')
        .eq('id', auctionId)
        .single();

      if (error || !data) return data;

      // Buscar lances recentes para nomes dos √∫ltimos lances
      const { data: bids } = await supabase
        .from('bids')
        .select('user_id, created_at')
        .eq('auction_id', auctionId)
        .order('created_at', { ascending: false })
        .limit(5);

      let recentBidderNames: string[] = [];
      if (bids && bids.length > 0) {
        const userIds = bids.map(bid => bid.user_id);
        const { data: profiles } = await supabase
          .from('profiles')
          .select('user_id, full_name')
          .in('user_id', userIds);

        const userNameMap = new Map();
        profiles?.forEach(profile => {
          userNameMap.set(profile.user_id, profile.full_name || 'Usu√°rio');
        });

        recentBidderNames = bids.map(bid => 
          userNameMap.get(bid.user_id) || 'Usu√°rio'
        );
      }

      const updatedData = {
        currentPrice: data.current_price || 0,
        totalBids: data.total_bids || 0,
        recentBidders: recentBidderNames,
        winnerName: data.winner_name
      };

      setAuctionData(updatedData);
      return data;
    } catch (error) {
      console.error(`‚ùå [${auctionId}] Erro ao buscar dados completos:`, error);
      return null;
    }
  }, [auctionId]);

  // Verificar novos lances - vers√£o otimizada com refs est√°veis
  const checkForNewBids = useCallback(async () => {
    if (!auctionId || auctionStatusRef.current !== 'active') return;

    try {
      // Query simples para verificar apenas as informa√ß√µes essenciais
      const { data, error } = await supabase
        .from('auctions')
        .select('id, total_bids, last_bid_at, status')
        .eq('id', auctionId)
        .single();

      if (error || !data) {
        console.error(`‚ùå [${auctionId}] Erro na verifica√ß√£o de lances:`, error);
        return;
      }

      // Se leil√£o foi finalizado, parar todos os timers
      if (data.status === 'finished') {
        console.log(`üèÅ [${auctionId}] Leil√£o finalizado`);
        setAuctionStatus('finished');
        setIsVerifying(false);
        clearTimers();
        return;
      }

      // Se est√° verificando h√° muito tempo, for√ßar refresh do status
      if (isVerifyingRef.current && localTimeLeftRef.current === 0) {
        const timeSinceVerifying = Date.now() - (lastVerifyingStart.current || Date.now());
        if (timeSinceVerifying > 5000) { // 5 segundos
          console.log(`‚è∞ [${auctionId}] Timeout na verifica√ß√£o, for√ßando refresh...`);
          setIsVerifying(false);
          startLocalTimer(15); // Resetar timer
        }
      }

      const currentBidCount = data.total_bids || 0;
      const newLastBidAt = data.last_bid_at;

      // Detectar novo lance usando refs para evitar recria√ß√µes
      if (currentBidCount > lastBidCountRef.current || (newLastBidAt && newLastBidAt !== lastBidAtRef.current)) {
        console.log(`üéØ [${auctionId}] Novo lance detectado! Atualizando dados completos...`);
        
        // Atualizar estados e refs
        setLastBidAt(newLastBidAt);
        setLastBidCount(currentBidCount);
        lastBidAtRef.current = newLastBidAt;
        lastBidCountRef.current = currentBidCount;
        
        // S√≥ buscar dados completos quando detectar novo lance
        try {
          await fetchCompleteAuctionData();
        } catch (fetchError) {
          console.error(`‚ùå [${auctionId}] Erro ao buscar dados completos:`, fetchError);
        }
        
        // Resetar timer para 15 segundos
        console.log(`üÜï [${auctionId}] NOVO LANCE! Resetando timer para 15s`);
        startLocalTimer(15);
      }

    } catch (error) {
      console.error(`‚ùå [${auctionId}] Erro ao verificar novos lances:`, error);
    }
  }, [auctionId, startLocalTimer, clearTimers, fetchCompleteAuctionData]);

  // Inicializa√ß√£o do sistema - sem depend√™ncia circular
  const initialize = useCallback(async () => {
    try {
      console.log(`üîÑ [${auctionId}] Inicializando sistema de timer...`);
      
      const { data, error } = await supabase
        .from('auctions')
        .select('time_left, last_bid_at, total_bids, status')
        .eq('id', auctionId)
        .single();

      if (error || !data) {
        console.error(`‚ùå [${auctionId}] Erro na inicializa√ß√£o:`, error);
        return;
      }

      // Definir estado inicial
      setLastBidAt(data.last_bid_at);
      setLastBidCount(data.total_bids);
      setAuctionStatus(data.status);
      
      // Atualizar refs tamb√©m
      lastBidAtRef.current = data.last_bid_at;
      lastBidCountRef.current = data.total_bids;
      auctionStatusRef.current = data.status;

      // Buscar dados completos iniciais
      await fetchCompleteAuctionData();

      if (data.status === 'finished') {
        console.log(`üèÅ [${auctionId}] Leil√£o j√° finalizado`);
        setIsVerifying(false);
        return;
      }

      // Iniciar timer local com time_left do backend
      const initialTime = data.time_left || 15;
      console.log(`‚ö° [${auctionId}] Iniciando com ${initialTime}s do backend`);
      startLocalTimer(initialTime);

      // Iniciar verifica√ß√£o de novos lances a cada 500ms (direto, sem depend√™ncia)
      if (bidCheckIntervalRef.current) {
        clearInterval(bidCheckIntervalRef.current);
      }
      bidCheckIntervalRef.current = setInterval(() => {
        checkForNewBids();
      }, 500);
      console.log(`üëÄ [${auctionId}] Verifica√ß√£o de lances iniciada (500ms)`);

    } catch (error) {
      console.error(`‚ùå [${auctionId}] Erro na inicializa√ß√£o:`, error);
    }
  }, [auctionId, startLocalTimer, fetchCompleteAuctionData, checkForNewBids]);

  // Integra√ß√£o com Page Visibility API para for√ßar sync ap√≥s inatividade
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden && isInitialized) {
        console.log(`üëÄ [${auctionId}] Usu√°rio voltou √† aba, for√ßando sincroniza√ß√£o completa...`);
        fetchCompleteAuctionData();
        checkForNewBids();
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
  }, [auctionId, isInitialized, checkForNewBids]);

  // Effect de inicializa√ß√£o
  useEffect(() => {
    let isMounted = true;
    
    const init = async () => {
      await initialize();
      if (isMounted) {
        setIsInitialized(true);
      }
    };

    init();

    return () => {
      isMounted = false;
      clearTimers();
    };
  }, [auctionId, initialize, clearTimers]);

  console.log(`üìä [${auctionId}] Estado: timer=${localTimeLeft}s | verificando=${isVerifying} | status=${auctionStatus}`);

  return {
    backendTimeLeft: localTimeLeft,
    isVerifying,
    isInitialized,
    auctionStatus,
    // Retornar dados sincronizados do leil√£o
    currentPrice: auctionData.currentPrice,
    totalBids: auctionData.totalBids,
    recentBidders: auctionData.recentBidders,
    winnerName: auctionData.winnerName
  };
};